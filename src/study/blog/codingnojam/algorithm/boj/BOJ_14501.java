package study.blog.codingnojam.algorithm.boj;

import java.util.Scanner;

public class BOJ_14501 {

    // 백준온라인저지 14501번 퇴사문제 Java로 문제 풀이
    public static void main(String[] args) {

        // 입력정보 받을 객체
        Scanner sc = new Scanner(System.in);

        // 상담 가능한 일수
        int N = sc.nextInt();

        // 배열의 0인덱스를 안쓰기 위해 길이 1추가
        // 인덱스가 곧 근무일수가 됨
        int[][] info = new int[N+1][2];

        // 문제에서 주어지는 정보로 배열초기화
        // DP로 쉽게 풀기위해 정보를 거꾸로 받습니다.
        // 즉, 마지막날 상담정보가 배열의 제일 첫번째로
        // 이렇게 하는 이유는 배열의 인덱스가 근무 가능한 일수가 되야하므로
        // 예를들어 i가 1이면 1일짜리만 가능,
        // i가 5이면 5일이하의 상담만 가능
        // 이런식으로 하기 위해 뒤집어서 정보를 받아서 초기화합니다.
        for (int i = N; i > 0; i--) {
            int T = sc.nextInt();
            int P = sc.nextInt();
            info[i][0] = T;
            info[i][1] = P;
        }

        // DP를 위한 배열
        // DP배열 또한 인덱스를 날짜로 사용하기 위해 길이를 1증가
        int[] dp = new int[N + 1];

        // DP 배열을 채워갑니다.
        // dp[i]가 의미하는 바는 다음과 같습니다.
        // 근무 가능한 일수가 i일 때 최대 벌 수 있는 비용
        // dp[1]은 마지막날의 상담을 골라서 했을 떄 가지는 최대 비용값
        // dp[N]은 첫째날부터 마지막날까지 상담을 골라서 했을 때 가지는 최대 비용값
        // 왜그러냐면 마지막날인 경우를 보면 다음날 퇴사를 하기 때문에 근무가능한 일수가 1입니다.
        // 그러므로 i는 근무가능한 일수를 의미합니다.
        // 앞서 정보를 뒤집어서 저장한 이유도 이를 좀더 수월하게 하기 위해서입니다.
        for (int i = 1; i < dp.length; i++) {
            if (info[i][0] > i) {
                // 해당 일자에 주어진 상담업무를 할 수 없는 경우에는 제외하고
                // 그 전의 근무가능한 일수에서의 최대비용값을 가져옴
                dp[i] = dp[i - 1];
            } else {
                // 해당 일자에 주어진 상담업무를 할 수 있는 경우
                // 1. 상담업무를 하지 않았을 때의 경우와
                // 2. 상담해서 번 비용 + dp[근무가능일수 - 해당상담일자]
                // 1과 2를 비교해서 큰 값이 해당 dp의 값이 됩니다.
                // dp[근무가능일수 - 해당상담일자]의 값은 앞에서 미리 계산되어있습니다.
                dp[i] = Math.max(dp[i - 1], info[i][1] + dp[i - info[i][0]]);
            }
        }

        // 출력
        System.out.println(dp[N]);
    }

}
